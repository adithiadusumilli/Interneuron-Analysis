% chunked cross-correlation per muscle (loop across animals, with permutation option, no plotting/controls)
% script version of runChunkedCrossCorrelationPerMuscle_Tiled
% cortex only, per emg channel (1–4), avg across neurons, concat across events
% jobInd = 0  → unpermuted
% jobInd > 0  → one permutation per run (permInd = jobInd)

% base dirs for animals
baseDirs = {
    '/home/asa7288/Transfer/D026', ...
    '/home/asa7288/Transfer/D020', ...
    '/home/asa7288/Transfer/D024' ...
};

% manually set jobInd before running this script
% example:
%   jobInd = 0;  % unpermuted
%   jobInd = 1;  % first permutation, etc.

if jobInd == 0
    isPermuted = false;
    permInd = 0;
else
    isPermuted = true;
    permInd = jobInd;
end

% params
chunkHalf      = 200;   % 401 samples total
maxLagSecs     = 0.5;
doBaselineNorm = true;
channelsToPlot = 1:4;   % muscles 1–4

for iDir = 1:numel(baseDirs)
    baseDir = baseDirs{iDir};
    fprintf('\nprocessing cortex session %d: %s (job %d)\n', iDir, baseDir, jobInd);

    % load emg-triggered neural activity windows (cortex only)
    S = load(fullfile(baseDir, 'EMG_Neural_AllChannels.mat'), ...
             'pyrCxWinCell','intCxWinCell','tAxis');

    % sampling and sizes
    tAxis = S.tAxis(:)';  % seconds (e.g., -0.5:0.001:0.5)
    binSize = 0.001;
    T = numel(tAxis);     % typically 1001 for -0.5..+0.5 s in 1 ms bins

    % center index (t=0)
    [~, cIdx] = min(abs(tAxis - 0));

    % base pyr subchunk indices: [cIdx-chunkHalf : cIdx+chunkHalf]
    pyrStart = cIdx - chunkHalf;
    pyrEnd   = cIdx + chunkHalf;

    % clip max lag in bins so int subchunk remains in range for all lags
    reqMaxLagBins = round(maxLagSecs / binSize);
    maxLagLeft  = pyrStart - 1;
    maxLagRight = T - pyrEnd;
    maxLagBins  = min([reqMaxLagBins, maxLagLeft, maxLagRight]);
    lags = -maxLagBins:maxLagBins;  % integer lag bins

    % per-muscle / emg channel
    for idx = 1:numel(channelsToPlot)
        ch = channelsToPlot(idx);

        % skip missing channels
        if ch > numel(S.pyrCxWinCell) || isempty(S.pyrCxWinCell{ch}) || isempty(S.intCxWinCell{ch})
            fprintf('channel %d missing or empty; skipping.\n', ch);
            continue;
        end

        pyrWin = S.pyrCxWinCell{ch};   % events×neurons×time
        intWin = S.intCxWinCell{ch};   % events×neurons×time
        if isempty(pyrWin) || isempty(intWin)
            fprintf('channel %d has empty event matrices; skipping.\n', ch);
            continue;
        end

        % events×time, with or without permutation of neuron labels
        if isPermuted
            [nEvtP, nPyr, ~] = size(pyrWin);
            [nEvtI, nInt, ~] = size(intWin);
            nEvt = min(nEvtP, nEvtI);
            if nPyr + nInt < 2 || nEvt < 1
                fprintf('channel %d: not enough neurons/events for permutation; skipping.\n', ch);
                continue;
            end

            % pool neurons and shuffle labels
            pooledWin = cat(2, pyrWin(1:nEvt,:,:), intWin(1:nEvt,:,:));  % events × (nPyr+nInt) × time
            totN = nPyr + nInt;
            idxAll = randperm(totN);
            idxP = idxAll(1:nPyr);
            idxI = idxAll(nPyr+1:end);

            pyrEvt = squeeze(mean(pooledWin(:, idxP, :), 2, 'omitnan')); % events×time
            intEvt = squeeze(mean(pooledWin(:, idxI, :), 2, 'omitnan')); % events×time
        else
            % avg across neurons -> events×time
            pyrEvt = squeeze(mean(pyrWin, 2, 'omitnan'));
            intEvt = squeeze(mean(intWin, 2, 'omitnan'));
        end

        if isempty(pyrEvt) || isempty(intEvt)
            fprintf('channel %d: empty pyr/int evt after processing; skipping.\n', ch);
            continue;
        end

        % optional per-trial baseline subtraction in [-0.2, -0.15] s
        if doBaselineNorm
            pyrEvt = subtractTrialBaseline(pyrEvt, tAxis, -0.2, -0.15);
            intEvt = subtractTrialBaseline(intEvt, tAxis, -0.2, -0.15);
        end

        % wrap into single-element cell arrays for lagSweepAcrossChannels
        pyr_byCh = {pyrEvt};
        int_byCh = {intEvt};

        % compute lag-swept correlation using shared helper
        tic
        [xc, peakLagSec] = lagSweepAcrossChannels(pyr_byCh, int_byCh, lags, pyrStart, pyrEnd, T, binSize);
        disp(['channel ' num2str(ch) ' cross-correlation done, time: ' num2str(toc) ' s'])

        % save per-channel outputs in quest_runs
        outDir = fullfile(baseDir, 'quest_runs');
        if ~exist(outDir, 'dir'), mkdir(outDir); end

        if isPermuted
            outFile = fullfile(outDir, ...
                sprintf('concatCrossCorrPerMuscle_perm_%03d_ch%02d.mat', permInd, ch));
        else
            outFile = fullfile(outDir, ...
                sprintf('concatCrossCorrPerMuscle_unperm_ch%02d.mat', ch));
        end

        save(outFile, 'lags','binSize','xc','peakLagSec','chunkHalf','ch', ...
            'doBaselineNorm','isPermuted','jobInd','permInd','baseDir');

        fprintf('saved: %s\n', outFile);
    end
end



% ===================== helpers =====================

function Eout = subtractTrialBaseline(Ein, tAxisSec, tStartSec, tEndSec)
    [~, iStart] = min(abs(tAxisSec - tStartSec));
    [~, iEnd]   = min(abs(tAxisSec - tEndSec));
    if iEnd < iStart, tmp = iStart; iStart = iEnd; iEnd = tmp; end
    baselines = mean(Ein(:, iStart:iEnd), 2, 'omitnan');  % events×1
    Eout = Ein - baselines;  % implicit expansion per-event
end

function [xc, peakLagSec] = lagSweepAcrossChannels(pyr_byCh, int_byCh, lags, pyrStart, pyrEnd, T, binSize)
    xc = nan(1, numel(lags));
    for iL = 1:numel(lags)
        L = lags(iL);
        intStart = pyrStart - L;
        intEnd   = pyrEnd   - L;
        if intStart < 1 || intEnd > T
            continue;
        end

        pvec = [];
        ivec = [];
        for ci = 1:numel(pyr_byCh)
            pEvt = pyr_byCh{ci};
            iEvt = int_byCh{ci};
            if isempty(pEvt) || isempty(iEvt)
                continue;
            end
            nEvt = min(size(pEvt,1), size(iEvt,1));
            for e = 1:nEvt
                pseg = pEvt(e, pyrStart:pyrEnd);
                iseg = iEvt(e, intStart:intEnd);
                pvec = [pvec, pseg]; %#ok<AGROW>
                ivec = [ivec, iseg]; %#ok<AGROW>
            end
        end

        valid = ~isnan(pvec) & ~isnan(ivec);
        if nnz(valid) > 10
            xc(iL) = corr(pvec(valid)', ivec(valid)');
        end
    end
    [~, peakIdx] = max(xc);
    peakLagSec = lags(peakIdx) * binSize;
end
