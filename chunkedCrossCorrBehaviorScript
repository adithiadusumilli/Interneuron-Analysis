% chunked cross-correlation per behavior (loop across animals, with permutation option, no plotting/controls)
%
% script version of runChunkedCrossCorrelationPerBehavior_Tiled
% cortex only, per umap behavior (1..7), pooling events across muscles/channels
% avg across neurons, optional per-trial baseline subtraction, concat across events
% jobInd = 0  -> unpermuted
% jobInd > 0  -> one permutation per run (permInd = jobInd)
%
% note: this script is now set to umap labels, and output filenames include the label type ("umap")

% base dirs for animals
baseDirs = {
    '/home/asa7288/Transfer/D026', ...
    '/home/asa7288/Transfer/D020', ...
    '/home/asa7288/Transfer/D024' ...
};

labelsToUse = 'umap';
labelTag = lower(labelsToUse);

rng(jobInd)

if jobInd == 0
    isPermuted = false;
    permInd = 0;
else
    isPermuted = true;
    permInd = jobInd;
end

% params
chunkHalf = 200; % 401 samples total
maxLagSecs = 0.5;
doBaselineNorm = true;

switch lower(labelsToUse)
    case 'umap'
        behaviors = 1:7;
    case 'manual'
        behaviors = 1:10;     % manual labels 1–10 (0 = unlabeled, ignored)
    case 'classifier'
        behaviors = 1:10;     % classifier labels 1–10 (0 = unlabeled, ignored)
    otherwise
        error('unknown labelsToUse: %s (use ''umap'', ''manual'', or ''classifier'')', labelsToUse);
end

for iDir = 1:numel(baseDirs)
    baseDir = baseDirs{iDir};
    fprintf('\nprocessing cortex session %d: %s | labels = %s | job %d\n', ...
        iDir, baseDir, labelsToUse, jobInd);

    % load cortex emg-triggered windows
    S = load(fullfile(baseDir, 'EMG_Neural_AllChannels.mat'), ...
             'pyrCxWinCell','intCxWinCell','tAxis');

    % load behavior labels per transition
    L = load(fullfile(baseDir, 'transitionBehaviorLabels.mat'), ...
             'regionLabelsPerTransition','manualLabelsPerTransition',...
             'classifierLabelsPerTransition');

    switch lower(labelsToUse)
        case 'umap'
            labelsPerTransition = L.regionLabelsPerTransition;
        case 'manual'
            labelsPerTransition = L.manualLabelsPerTransition;
        case 'classifier'
            labelsPerTransition = L.classifierLabelsPerTransition;
    end

    % sampling and sizes
    tAxis  = S.tAxis(:)'; % seconds, e.g. -0.5:0.001:0.5
    binSize = 0.001;
    T      = numel(tAxis);

    % center index (t = 0)
    [~, cIdx] = min(abs(tAxis - 0));

    % pyr subchunk indices [cIdx-chunkHalf : cIdx+chunkHalf]
    pyrStart = cIdx - chunkHalf;
    pyrEnd   = cIdx + chunkHalf;

    % clip max lag in bins so int subchunk stays within [1..T]
    reqMaxLagBins = round(maxLagSecs / binSize);
    maxLagLeft = pyrStart - 1;
    maxLagRight = T - pyrEnd;
    maxLagBins = min([reqMaxLagBins, maxLagLeft, maxLagRight]);
    lags = -maxLagBins:maxLagBins;  % integer lag bins

    % number of channels
    nCh = numel(S.pyrCxWinCell);

    % helper: events×neurons×time -> events×time
    meanEvt = @(M) meanEvt_keepEvents(M);

    function E = meanEvt_keepEvents(M)
        % averages over neurons (dim 2) and guarantees output is events×time
        % even when events == 1 (avoids squeeze collapsing dimensions)
        % input:  M is events×neurons×time
        % output: E is events×time

        if isempty(M)
            E = [];
            return;
        end

        E = mean(M, 2, 'omitnan'); % events×1×time
        E = permute(E, [1 3 2]); % events×time×1
        E = reshape(E, size(E,1), size(E,2)); % events×time
    end


    % main loop over behaviors
    for bIdx = 1:numel(behaviors)
        beh = behaviors(bIdx);
        fprintf('  behavior %d\n', beh);

        % per-behavior, per-channel events×time holders
        pyr_byCh = cell(1, nCh);
        int_byCh = cell(1, nCh);

        % count total trials used for this behavior
        nTrialsThisBehavior = 0;

        for ch = 1:nCh
            % skip if no labels or no data
            if ch > numel(labelsPerTransition) || isempty(labelsPerTransition{ch})
                continue;
            end
            if isempty(S.pyrCxWinCell{ch}) || isempty(S.intCxWinCell{ch})
                continue;
            end

            pyrWin = S.pyrCxWinCell{ch};   % events×neurons×time
            intWin = S.intCxWinCell{ch};   % events×neurons×time
            if isempty(pyrWin) || isempty(intWin)
                continue;
            end

            labels = labelsPerTransition{ch}(:);
            if isempty(labels)
                continue;
            end

            % make sure we do not exceed available events in any array
            nEvtP = size(pyrWin,1);
            nEvtI = size(intWin,1);
            nLab  = numel(labels);
            nEvt  = min([nEvtP, nEvtI, nLab]);
            if nEvt < 1
                continue;
            end

            labels = labels(1:nEvt);
            behMask = (labels == beh);
            if ~any(behMask)
                continue;
            end

            evIdx = find(behMask);
            if isempty(evIdx)
                continue;
            end

            % select only events for this behavior
            pyrWin_sel = pyrWin(evIdx,:,:);
            intWin_sel = intWin(evIdx,:,:);

            % events×time, with or without permutation of neuron labels
            if isPermuted
                [nEvtSel, nPyr, ~] = size(pyrWin_sel);
                [nEvtSelI, nInt, ~] = size(intWin_sel);
                nEvtSel = min(nEvtSel, nEvtSelI);
                if nPyr + nInt < 2 || nEvtSel < 1
                    continue;
                end

                pyrWin_sel = pyrWin_sel(1:nEvtSel,:,:);
                intWin_sel = intWin_sel(1:nEvtSel,:,:);

                % pool neurons and shuffle labels
                pooledWin = cat(2, pyrWin_sel, intWin_sel);  % events × (nPyr+nInt) × time
                totN = nPyr + nInt;
                idxAll = randperm(totN);
                idxP = idxAll(1:nPyr);
                idxI = idxAll(nPyr+1:end);

                pyrEvt = meanEvt_keepEvents(pooledWin(:, idxP, :)); % events×time
                intEvt = meanEvt_keepEvents(pooledWin(:, idxI, :)); % events×time

            else
                % avg across neurons -> events×time
                pyrEvt = meanEvt(pyrWin_sel);
                intEvt = meanEvt(intWin_sel);
            end

            if isempty(pyrEvt) || isempty(intEvt)
                continue;
            end

            % optional per-trial baseline subtraction in [-0.2, -0.15] s
            if doBaselineNorm
                pyrEvt = subtractTrialBaseline(pyrEvt, tAxis, -0.2, -0.15);
                intEvt = subtractTrialBaseline(intEvt, tAxis, -0.2, -0.15);
            end

            pyr_byCh{ch} = pyrEvt;
            int_byCh{ch} = intEvt;

            nTrialsThisBehavior = nTrialsThisBehavior + size(pyrEvt,1);
        end

        % if no data for this behavior, skip saving
        if nTrialsThisBehavior == 0
            fprintf('    no trials for behavior %d; skipping.\n', beh);
            continue;
        end

        % compute lag-swept correlation pooling across channels/events
        tic
        [xc, peakLagSec] = lagSweepAcrossChannels(pyr_byCh, int_byCh, lags, pyrStart, pyrEnd, T, binSize);
        disp(['    behavior ' num2str(beh) ' cross-correlation done, time: ' num2str(toc) ' s'])

        % save per-behavior outputs in quest_runs
        outDir = fullfile(baseDir, 'quest_runs');
        if ~exist(outDir, 'dir'), mkdir(outDir); end

        if isPermuted
            outFile = fullfile(outDir, ...
                sprintf('concatCrossCorrPerBehavior_%s_perm_%03d_beh%02d.mat', ...
                labelTag, permInd, beh));
        else
            outFile = fullfile(outDir, ...
                sprintf('concatCrossCorrPerBehavior_%s_unperm_beh%02d.mat', ...
                labelTag, beh));
        end

        lagsSec = lags * binSize; %#ok<NASGU>
        nTrials = nTrialsThisBehavior; %#ok<NASGU>

        save(outFile, 'lags','lagsSec','binSize','xc','peakLagSec', ...
            'chunkHalf','beh','doBaselineNorm','isPermuted','jobInd', ...
            'permInd','baseDir','nTrials','labelsToUse');

        fprintf('    saved: %s\n', outFile);
    end
end

% ===================== helpers =====================

function Eout = subtractTrialBaseline(Ein, tAxisSec, tStartSec, tEndSec)
    [~, iStart] = min(abs(tAxisSec - tStartSec));
    [~, iEnd]   = min(abs(tAxisSec - tEndSec));
    if iEnd < iStart
        tmp = iStart;
        iStart = iEnd;
        iEnd = tmp;
    end

    % safety check
    if iStart < 1 || iEnd > size(Ein, 2) || iStart > iEnd
        % skip baseline subtraction here cuz invalid baseline window
        Eout = Ein;
        return;
    end

    baselines = mean(Ein(:, iStart:iEnd), 2, 'omitnan');  % events×1
    Eout = Ein - baselines;  % implicit expansion per-event
end

function [xc, peakLagSec] = lagSweepAcrossChannels(pyr_byCh, int_byCh, lags, pyrStart, pyrEnd, T, binSize)
    xc = nan(1, numel(lags));
    for iL = 1:numel(lags)
        L = lags(iL);
        intStart = pyrStart - L;
        intEnd   = pyrEnd   - L;
        if intStart < 1 || intEnd > T
            continue;
        end

        pvec = [];
        ivec = [];
        for ci = 1:numel(pyr_byCh)
            pEvt = pyr_byCh{ci};
            iEvt = int_byCh{ci};
            if isempty(pEvt) || isempty(iEvt)
                continue;
            end

            % safety: ensure indices exist
            if size(pEvt, 2) < pyrEnd || size(iEvt, 2) < intEnd
                continue;
            end

            nEvt = min(size(pEvt,1), size(iEvt,1));
            for e = 1:nEvt
                pseg = pEvt(e, pyrStart:pyrEnd);
                iseg = iEvt(e, intStart:intEnd);
                pvec = [pvec, pseg]; %#ok<AGROW>
                ivec = [ivec, iseg]; %#ok<AGROW>
            end
        end

        valid = ~isnan(pvec) & ~isnan(ivec);
        if nnz(valid) > 10
            xc(iL) = corr(pvec(valid)', ivec(valid)');
        end
    end

    [~, peakIdx] = max(xc);
    peakLagSec = lags(peakIdx) * binSize;
end
