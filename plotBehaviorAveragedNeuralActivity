function plotBehaviorAveragedNeuralActivity(folderPath, channelsToUse, doBaselineNorm)
% plots cortex pyramidal + interneuron activity per behavior class
% behavior classes come from transitionBehaviorLabels.mat
% uses same baseline norm + shifted control logic as plotEMGandNeuralAverageswNorm

    if nargin < 2 || isempty(channelsToUse), channelsToUse = 1:4; end
    if nargin < 3 || isempty(doBaselineNorm), doBaselineNorm = true; end

    % add shadederrorbar
    sep = 'c:\github\interneuron-analysis';
    fcn = fullfile(sep,'shadedErrorBar.m');
    if exist(fcn,'file'), addpath(genpath(sep)); end

    % -------- load emg + neural windows (output of extractEMGandNeuralWindows) --------
    dataFile = fullfile(folderPath,'EMG_Neural_AllChannels.mat');
    S = load(dataFile, ...
        'pyrCxWinCell','intCxWinCell', ...
        'pyrCxWinShiftedCell','intCxWinShiftedCell', ...
        'pyrCxWinShiftedMeanCell','intCxWinShiftedMeanCell', ...
        'tAxis','validTransitionsCell');

    tAxis = S.tAxis;

    % -------- load behavior labels per transition --------
    % produced by your transition label mapping code
    L = load(fullfile(folderPath,'transitionBehaviorLabels.mat'), ...
        'regionLabelsPerTransition', ...    % umap 1–7
        'manualLabelsPerTransition', ...    % manual 0–10
        'classifierLabelsPerTransition');   % classifier 0–10 (0 = unlabeled)

    % -------- helper funcs (same style as your working function) --------

    % avg across neurons -> events x time
    meanEvt = @(M) permute(mean(M, 2, 'omitnan'), [1 3 2]);

    % grand mean and sem across events
    grandMS = @(E) deal(mean(E,1,'omitnan'), std(E,0,1,'omitnan')./sqrt(size(E,1)));

    % per-trial baseline subtraction using -200 to -150 ms window
    function Eout = subtractTrialBaseline(Ein, tAxisLocal, tStart, tEnd)
        % ein: events x time
        if isempty(Ein)
            Eout = Ein;
            return;
        end
        [~, iStart] = min(abs(tAxisLocal - tStart));
        [~, iEnd]   = min(abs(tAxisLocal - tEnd));
        if iEnd < iStart
            tmp = iStart; iStart = iEnd; iEnd = tmp;
        end
        baselines = mean(Ein(:, iStart:iEnd), 2, 'omitnan'); % events x 1
        Eout = Ein - baselines;
    end

    % core helper: compute per-behavior averages + shifted percentiles
    % labelCell is the cell array for one label type (umap / manual / classifier)
    function [mPyr, sePyr, mInt, seInt, pctPyr, pctInt, nEvt] = ...
            doOneBehavior(labelCell, bVal)

        pyrPool  = []; % events x time
        intPool  = [];
        shiftPyr = []; % rows = shifts x time
        shiftInt = [];

        for ch = channelsToUse
            % behavior labels for this muscle's transitions
            if ch > numel(labelCell) || isempty(labelCell{ch})
                continue;
            end
            labels = labelCell{ch}(:);

            if ch > numel(S.validTransitionsCell) || isempty(S.validTransitionsCell{ch})
                continue;
            end

            % mask transitions that equal this behavior code
            mask = (labels == bVal) & ~isnan(labels);
            if ~any(mask)
                continue;
            end

            % ----- unshifted neural windows for this channel -----
            pyrAll = S.pyrCxWinCell{ch};   % events x neurons x time
            intAll = S.intCxWinCell{ch};

            if isempty(pyrAll) || isempty(intAll)
                continue;
            end

            % safety: make mask not longer than #events
            nEvtChan = size(pyrAll,1);
            if numel(mask) > nEvtChan
                mask = mask(1:nEvtChan);
            end

            % select only events belonging to this behavior
            pyrSel = pyrAll(mask,:,:);
            intSel = intAll(mask,:,:);
            if isempty(pyrSel) || isempty(intSel)
                continue;
            end

            % avg across neurons -> events x time
            Ep = meanEvt(pyrSel);
            Ei = meanEvt(intSel);

            % baseline norm per event
            if doBaselineNorm
                Ep = subtractTrialBaseline(Ep, tAxis, -200, -150);
                Ei = subtractTrialBaseline(Ei, tAxis, -200, -150);
            end

            pyrPool = [pyrPool; Ep]; %#ok<AGROW>
            intPool = [intPool; Ei]; %#ok<AGROW>

            % ----- shifted controls: first full shift -----
            pyrShiftFull = S.pyrCxWinShiftedCell{ch};
            intShiftFull = S.intCxWinShiftedCell{ch};
            if ~isempty(pyrShiftFull) && ~isempty(intShiftFull)
                nEvtShift = size(pyrShiftFull,1);
                mask1 = mask;
                if numel(mask1) > nEvtShift
                    mask1 = mask1(1:nEvtShift);
                end
                pyrShiftSel = pyrShiftFull(mask1,:,:);
                intShiftSel = intShiftFull(mask1,:,:);

                Ep1 = meanEvt(pyrShiftSel);
                Ei1 = meanEvt(intShiftSel);

                if doBaselineNorm
                    Ep1 = subtractTrialBaseline(Ep1, tAxis, -200, -150);
                    Ei1 = subtractTrialBaseline(Ei1, tAxis, -200, -150);
                end

                shiftPyr = [shiftPyr; mean(Ep1,1,'omitnan')]; %#ok<AGROW>
                shiftInt = [shiftInt; mean(Ei1,1,'omitnan')]; %#ok<AGROW>
            end

            % ----- shifted controls: remaining 99 mean-only shifts -----
            pyrShiftCells = S.pyrCxWinShiftedMeanCell(ch,:); % 1x99 cells
            intShiftCells = S.intCxWinShiftedMeanCell(ch,:);

            for k = 1:numel(pyrShiftCells)
                EpAll = pyrShiftCells{k};
                EiAll = intShiftCells{k};
                if isempty(EpAll) || isempty(EiAll)
                    continue;
                end

                nEvtK = size(EpAll,1);
                maskK = mask;
                if numel(maskK) > nEvtK
                    maskK = maskK(1:nEvtK);
                end

                EpK = EpAll(maskK,:);
                EiK = EiAll(maskK,:);
                if isempty(EpK) || isempty(EiK)
                    continue;
                end

                if doBaselineNorm
                    EpK = subtractTrialBaseline(EpK, tAxis, -200, -150);
                    EiK = subtractTrialBaseline(EiK, tAxis, -200, -150);
                end

                shiftPyr = [shiftPyr; mean(EpK,1,'omitnan')]; %#ok<AGROW>
                shiftInt = [shiftInt; mean(EiK,1,'omitnan')]; %#ok<AGROW>
            end
        end

        % if nothing pooled, return empties so caller can skip plot
        if isempty(pyrPool) || isempty(intPool)
            mPyr = []; sePyr = [];
            mInt = []; seInt = [];
            pctPyr = []; pctInt = [];
            nEvt = 0;
            return;
        end

        % total event count pooled across channels for this behavior
        nEvt = size(pyrPool,1);

        % unshifted mean ± sem
        [mPyr, sePyr] = grandMS(pyrPool);
        [mInt, seInt] = grandMS(intPool);

        % 2.5 / 97.5 percentiles for shifted controls
        pctPyr = prctile(shiftPyr, [2.5 97.5], 1);
        pctInt = prctile(shiftInt, [2.5 97.5], 1);
    end

    % ============================================================
    % 1) umap regions 1–7
    % ============================================================
    umapVals = 1:7;

    figure('Name','cortex neural by umap behavior','Color','w');
    tiledlayout(2,4,'TileSpacing','tight','Padding','compact');

    for b = umapVals
        [mPyr, sePyr, mInt, seInt, pctPyr, pctInt, nEvt] = ...
            doOneBehavior(L.regionLabelsPerTransition, b);

        nexttile(b); hold on;

        if isempty(mPyr) || isempty(mInt)
            axis off;
            title(sprintf('umap %d (no events)', b));
            continue;
        end

        yyaxis left
        shadedErrorBar(tAxis, mPyr, sePyr, 'lineProps', {'b','LineWidth',1.5});
        plot(tAxis, pctPyr(1,:), 'b--');
        plot(tAxis, pctPyr(2,:), 'b--');
        ylabel('pyramidal');

        yyaxis right
        shadedErrorBar(tAxis, mInt, seInt, 'lineProps', {'r','LineWidth',1.5});
        plot(tAxis, pctInt(1,:), 'r--');
        plot(tAxis, pctInt(2,:), 'r--');
        ylabel('interneuron');

        xlabel('time (ms)');
        xlim([-150 500]);  % only show -150 to 500 ms
        title(sprintf('umap %d (n = %d)', b, nEvt));
    end

    sgtitle(sprintf('cortex neural activity by umap behavior (1–7)%s', ...
        tern(doBaselineNorm,' – baseline-subtracted','')));

    % ============================================================
    % 2) manual labels 0–10
    % ============================================================
    manualVals = 0:10;

    figure('Name','cortex neural by manual label','Color','w');
    tiledlayout(3,4,'TileSpacing','tight','Padding','compact');

    for b = manualVals
        [mPyr, sePyr, mInt, seInt, pctPyr, pctInt, nEvt] = ...
            doOneBehavior(L.manualLabelsPerTransition, b);

        tileIdx = b + 1;
        nexttile(tileIdx); hold on;

        if isempty(mPyr) || isempty(mInt)
            axis off;
            title(sprintf('manual %d (no events)', b));
            continue;
        end

        yyaxis left
        shadedErrorBar(tAxis, mPyr, sePyr, 'lineProps', {'b','LineWidth',1.5});
        plot(tAxis, pctPyr(1,:), 'b--');
        plot(tAxis, pctPyr(2,:), 'b--');
        ylabel('pyramidal');

        yyaxis right
        shadedErrorBar(tAxis, mInt, seInt, 'lineProps', {'r','LineWidth',1.5});
        plot(tAxis, pctInt(1,:), 'r--');
        plot(tAxis, pctInt(2,:), 'r--');
        ylabel('interneuron');

        xlabel('time (ms)');
        xlim([-150 500]);
        title(sprintf('manual %d (n = %d)', b, nEvt));
    end

    sgtitle(sprintf('cortex neural activity by manual behavior (0–10)%s', ...
        tern(doBaselineNorm,' – baseline-subtracted','')));

    % ============================================================
    % 3) classifier labels 0–10 (0 = unlabeled)
    % ============================================================
    classVals = 0:10;

    figure('Name','cortex neural by classifier label','Color','w');
    tiledlayout(3,4,'TileSpacing','tight','Padding','compact');

    for b = classVals
        [mPyr, sePyr, mInt, seInt, pctPyr, pctInt, nEvt] = ...
            doOneBehavior(L.classifierLabelsPerTransition, b);

        tileIdx = b + 1;
        nexttile(tileIdx); hold on;

        if isempty(mPyr) || isempty(mInt)
            axis off;
            title(sprintf('classifier %d (no events)', b));
            continue;
        end

        yyaxis left
        shadedErrorBar(tAxis, mPyr, sePyr, 'lineProps', {'b','LineWidth',1.5});
        plot(tAxis, pctPyr(1,:), 'b--');
        plot(tAxis, pctPyr(2,:), 'b--');
        ylabel('pyramidal');

        yyaxis right
        shadedErrorBar(tAxis, mInt, seInt, 'lineProps', {'r','LineWidth',1.5});
        plot(tAxis, pctInt(1,:), 'r--');
        plot(tAxis, pctInt(2,:), 'r--');
        ylabel('interneuron');

        xlabel('time (ms)');
        xlim([-150 500]);
        title(sprintf('classifier %d (n = %d)', b, nEvt));
    end

    sgtitle(sprintf('cortex neural activity by classifier behavior (0–10)%s', ...
        tern(doBaselineNorm,' – baseline-subtracted','')));

end

% tiny ternary helper for title string
function out = tern(cond, a, b)
    if cond, out = a; else, out = b; end
end
