function runChunkedCrossCorrelation(animalFolder, channelsToUse, chunkHalf, maxLagSecs, doBaselineNorm, nPerm)
% computes xc using per-window subchunks, then concats the subchunks
% each lag uses 401 samples per window (default = -200..+200) from pyr and int uses the same # but shifted by -lag (in bins)
% no nan padding -- nans removed synchronously after concat

% inputs:
%   animalfolder: folder w 'emg_neural_allchannels.mat'
%   channelsToUse: which emg channels to include (default is 1:4)
%   chunkhalf: half-length of subchunk (default 200 -> 400 samples)
%   maxLagsSecs: desired max lag in secs (but will be clipped to fit windows)
%   doBaselineNorm: logical, per-trial baseline subtract in [-200,-150] ms (default true)
%   nPerm: # of label-shuffle permutations (default 100)

% outputs (saved):
%   lags, binSize, xc, peakLagSec, ctrlCorrs, ctrlMean, ctrlSEM, doBaselineNorm
%   permPeakLagSecs, propLessSigned, propLessAbs, permIsSigSigned, permIsSigAbs, nPerm

if nargin < 2 || isempty(channelsToUse), channelsToUse = 1:4; end
if nargin < 3 || isempty(chunkHalf), chunkHalf = 200; end % 400 = 200*2
if nargin < 4 || isempty(maxLagSecs), maxLagSecs = 0.5; end
if nargin < 5 || isempty(doBaselineNorm), doBaselineNorm = true; end
if nargin < 6 || isempty(nPerm), nPerm = 100; end

% load emg-triggered neural activity windows
S = load(fullfile(animalFolder, 'EMG_Neural_AllChannels.mat'), 'pyrCxWinCell','intCxWinCell','intCxWinShiftedCell','intCxWinShiftedMeanCell','tAxis');

% sampling and sizes
tAxis = S.tAxis(:)';
binSize = 0.001;
T = numel(tAxis); % 1001 for -500:500

% center index where t=0
[~, cIdx] = min(abs(tAxis - 0));

% base subchunk in pyr is [cIdx-chunkHalf : cIdx+chunkHalf] → 2*chunkHalf+1 samples
pyrStart = cIdx - chunkHalf;
pyrEnd   = cIdx + chunkHalf;

% safety: make sure this is inside win
if pyrStart < 1 || pyrEnd > T
    error('chosen chunkHalf=%d does not fit inside the available window length=%d.', chunkHalf, T);
end

% clip max lag in bins so int shifted subchunk stays inside win for all lags
reqMaxLagBins = round(maxLagSecs / binSize);
maxLagLeft  = pyrStart - 1;
maxLagRight = T - pyrEnd;
maxLagBins  = min([reqMaxLagBins, maxLagLeft, maxLagRight]); % clip
lags = -maxLagBins:maxLagBins; % int bins

% helper: per-trial baseline subtraction on events×time (after neuron-avg)
function Eout = subtractTrialBaseline(Ein, tAxisSec, tStartSec, tEndSec)
    [~, iStart] = min(abs(tAxisSec - tStartSec));
    [~, iEnd]   = min(abs(tAxisSec - tEndSec));
    if iEnd < iStart, tmp = iStart; iStart = iEnd; iEnd = tmp; end
    baselines = mean(Ein(:, iStart:iEnd), 2, 'omitnan');  % events×1
    Eout = Ein - baselines;  % implicit expansion per event
end

%% ----------- UNPERMUTED: lag sweep -----------
xc = nan(1, numel(lags));

for iL = 1:numel(lags)
    L = lags(iL);  % +L means int chunk is shifted left by L bins (i.e. leads)

    % idx for int subchunk (shifted by -L)
    intStart = pyrStart - L;
    intEnd   = pyrEnd   - L;
    if intStart < 1 || intEnd > T, continue; end

    % holders for concat per-window subchunks
    pyrVec = [];
    intVec = [];

    % iterate chans then events, extracting subchunks and concat
    for ch = channelsToUse
        pyrWin = S.pyrCxWinCell{ch};   % events × neurons × time
        intWin = S.intCxWinCell{ch};   % events × neurons × time
        if isempty(pyrWin) || isempty(intWin), continue; end

        % avg across neurons -> events × time
        pyrEvt = squeeze(mean(pyrWin, 2, 'omitnan'));
        intEvt = squeeze(mean(intWin, 2, 'omitnan'));
        if isempty(pyrEvt) || isempty(intEvt), continue; end

        % optional per-trial baseline subtraction using -200 to -150 ms
        if doBaselineNorm
            pyrEvt = subtractTrialBaseline(pyrEvt, tAxis, -0.2, -0.15);
            intEvt = subtractTrialBaseline(intEvt, tAxis, -0.2, -0.15);
        end

        % for each event, pull pyr subchunk and shifted int subchunk
        nEvt = min(size(pyrEvt,1), size(intEvt,1));
        for e = 1:nEvt
            pseg = pyrEvt(e, pyrStart:pyrEnd);
            iseg = intEvt(e, intStart:intEnd);
            pyrVec = [pyrVec, pseg];
            intVec = [intVec, iseg];
        end
    end

    % remove nans, preserve alignment
    valid = ~isnan(pyrVec) & ~isnan(intVec);
    if nnz(valid) > 10
        xc(iL) = corr(pyrVec(valid)', intVec(valid)');
    end
end

% find peak lag (in seconds)
[~, peakIdx] = max(xc);
peakLagSec = lags(peakIdx) * binSize;

%% ----------- CONTROL (shifted): mean ± SEM -----------
numStoredShifts = size(S.intCxWinShiftedMeanCell, 2); % typically 99
numShifts = 1 + numStoredShifts; % 1 (full) + 99 (means) = 100
ctrlCorrs = nan(1, numShifts);

for s = 1:numShifts
    pyrVec_ctrl = [];
    intVec_ctrl = [];

    for ch = channelsToUse
        % pyr (unshifted): events×neurons×time → avg over neurons → events×time
        pyrEvt = squeeze(mean(S.pyrCxWinCell{ch}, 2, 'omitnan'));

        % int (already shifted for this s)
        if s == 1
            intEvt = squeeze(mean(S.intCxWinShiftedCell{ch}, 2, 'omitnan'));
        else
            intEvt = S.intCxWinShiftedMeanCell{ch, s-1};
        end

        if isempty(pyrEvt) || isempty(intEvt), continue; end

        % optional baseline subtraction
        if doBaselineNorm
            pyrEvt = subtractTrialBaseline(pyrEvt, tAxis, -0.2, -0.15);
            intEvt = subtractTrialBaseline(intEvt, tAxis, -0.2, -0.15);
        end

        nEvt = min(size(pyrEvt,1), size(intEvt,1));
        for e = 1:nEvt
            pseg = pyrEvt(e, pyrStart:pyrEnd);   % unshifted center window
            iseg = intEvt(e, pyrStart:pyrEnd);   % already shifted in data
            pyrVec_ctrl = [pyrVec_ctrl, pseg];
            intVec_ctrl = [intVec_ctrl, iseg];
        end
    end

    valid = ~isnan(pyrVec_ctrl) & ~isnan(intVec_ctrl);
    if nnz(valid) > 10
        ctrlCorrs(s) = corr(pyrVec_ctrl(valid)', intVec_ctrl(valid)');
    end
end

ctrlMean = mean(ctrlCorrs, 'omitnan');
ctrlSEM  = std(ctrlCorrs, 'omitnan') / sqrt(sum(~isnan(ctrlCorrs)));

%% ----------- PERMUTATION TEST (shuffle neuron labels) -----------
% per chan: pool neurons pyr+int, shuffle labels but keep original counts, then recompute full lag-swept xcorr and take peak lag
permPeakLagSecs = nan(1, nPerm);

for p = 1:nPerm
    % precompute shuffled, neuron-averaged events×time per channel
    shufPyr_byCh = cell(1, numel(channelsToUse));
    shufInt_byCh = cell(1, numel(channelsToUse));

    for ci = 1:numel(channelsToUse)
        ch = channelsToUse(ci);
        pyrWin = S.pyrCxWinCell{ch};   % events × Np × time
        intWin = S.intCxWinCell{ch};   % events × Ni × time
        if isempty(pyrWin) || isempty(intWin), continue; end

        [nEvtP, nPyr, ~] = size(pyrWin);
        [nEvtI, nInt, ~] = size(intWin);
        nEvt = min(nEvtP, nEvtI);
        if nPyr + nInt < 2 || nEvt < 1, continue; end

        % pool neurons along dim-2
        pooledWin = cat(2, pyrWin(1:nEvt,:,:), intWin(1:nEvt,:,:));  % events × (nPyr+nInt) × time
        totN = nPyr + nInt;

        % shuffle neuron indices; first nPyr assigned to "pyr", rest to "int"
        idx = randperm(totN);
        idxP = idx(1:nPyr);
        idxI = idx(nPyr+1:end);

        shufPyrEvt = squeeze(mean(pooledWin(:, idxP, :), 2, 'omitnan')); % events×time
        shufIntEvt = squeeze(mean(pooledWin(:, idxI, :), 2, 'omitnan')); % events×time

        % optional baseline subtraction
        if doBaselineNorm
            shufPyrEvt = subtractTrialBaseline(shufPyrEvt, tAxis, -0.2, -0.15);
            shufIntEvt = subtractTrialBaseline(shufIntEvt, tAxis, -0.2, -0.15);
        end

        shufPyr_byCh{ci} = shufPyrEvt;
        shufInt_byCh{ci} = shufIntEvt;
    end

    % compute lag-swept xcorr for this permutation (pool across channels & events)
    xc_perm = nan(1, numel(lags));
    for iL = 1:numel(lags)
        L = lags(iL);
        intStart = pyrStart - L;
        intEnd   = pyrEnd   - L;
        if intStart < 1 || intEnd > T, continue; end

        pvec = []; ivec = [];
        for ci = 1:numel(channelsToUse)
            pEvt = shufPyr_byCh{ci};
            iEvt = shufInt_byCh{ci};
            if isempty(pEvt) || isempty(iEvt), continue; end
            nEvt = min(size(pEvt,1), size(iEvt,1));
            for e = 1:nEvt
                pseg = pEvt(e, pyrStart:pyrEnd);
                iseg = iEvt(e, intStart:intEnd);
                pvec = [pvec, pseg];
                ivec = [ivec, iseg];
            end
        end

        valid = ~isnan(pvec) & ~isnan(ivec);
        if nnz(valid) > 10
            xc_perm(iL) = corr(pvec(valid)', ivec(valid)');
        end
    end

    % record permuted peak lag
    [~, pIdx] = max(xc_perm);
    permPeakLagSecs(p) = lags(pIdx) * binSize;
end

% proportion of shuffled peak lags less than the actual (signed + absolute)
propLessSigned = mean(permPeakLagSecs < peakLagSec, 'omitnan');
propLessAbs = mean(abs(permPeakLagSecs) < abs(peakLagSec), 'omitnan');
permIsSigSigned = propLessSigned >= 0.95;
permIsSigAbs = propLessAbs >= 0.95;

%% ----------- Plot -----------
figure('Name','chunked window cross-correlation (with control mean ± sem + permutation test)', 'Color','w');
plot(lags * binSize, xc, 'k', 'LineWidth', 2); hold on;
if ~isnan(ctrlMean) && ~isnan(ctrlSEM)
    yline(ctrlMean - ctrlSEM, '--', 'Color', [0.5 0.5 0.5], 'LineWidth', 1.5);
    yline(ctrlMean + ctrlSEM, '--', 'Color', [0.5 0.5 0.5], 'LineWidth', 1.5);
end
xline(0, 'r--');
xline(peakLagSec, 'b--', sprintf('peak = %.3f s', peakLagSec), 'LabelVerticalAlignment','bottom');

xlabel('lag (s)'); ylabel('correlation');
ttl = sprintf(['chunked xcorr (pyr [-%d..+%d] vs int shifted, %d chans)\n' 'control mean \\pm sem; perm n=%d | frac(shuf<actual) signed=%.2f%s, abs=%.2f%s'], chunkHalf, chunkHalf, numel(channelsToUse), nPerm, propLessSigned, tern(permIsSigSigned,'*',''), propLessAbs, tern(permIsSigAbs,'*',''));
title(ttl);
legend({'xc (lags)','control mean \pm sem','0 lag','peak'}, 'Location','best');
grid on; box off;

%% ----------- Save -----------
outFile = fullfile(animalFolder, 'concatCrossCorr_chunked_withControl.mat');
save(outFile, 'lags','binSize','xc','peakLagSec','chunkHalf','channelsToUse', 'ctrlCorrs','ctrlMean','ctrlSEM','doBaselineNorm', 'permPeakLagSecs','propLessSigned','propLessAbs', 'permIsSigSigned','permIsSigAbs','nPerm');
fprintf('saved: %s\n', outFile);
end

function out = tern(cond, a, b)
    if cond, out = a; else, out = b; end
end
