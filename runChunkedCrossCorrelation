function runChunkedCrossCorrelation(animalFolder, channelsToUse, chunkHalf, maxLagSecs, doBaselineNorm)
% computes xc using per-window subchunks, then concats the subchunks
% each lag uses 401 samples per window (default = -200..+200) from pyr and int uses the same # but shifted by -lag (in bins)
% no nan padding; nans removed synchronously after concat

% inputs:
%   animalfolder: folder w 'emg_neural_allchannels.mat'
%   channelsToUse: which emg channels to include (default is 1:4)
%   chunkhalf: half-length of subchunk (default 200 -> 400 samples)
%   maxLagsSecs: desired max lag in secs (but will be clipped to fit windows)
%   doBaselineNorm: logical, per-trial baseline subtract in [-200,-150] ms (default true)

if nargin < 2 || isempty(channelsToUse), channelsToUse = 1:4; end
if nargin < 3 || isempty(chunkHalf), chunkHalf = 200; end % 400 = 200*2
if nargin < 4 || isempty(maxLagSecs), maxLagSecs = 0.5; end  % request; will be clipped
if nargin < 5 || isempty(doBaselineNorm), doBaselineNorm = true; end

% load emg-triggered neural activity windows
S = load(fullfile(animalFolder, 'EMG_Neural_AllChannels.mat'), ...
         'pyrCxWinCell','intCxWinCell','intCxWinShiftedCell','intCxWinShiftedMeanCell','tAxis');

% sampling and sizes
tAxis = S.tAxis(:)';
binSize = 0.001;
T = numel(tAxis); % 1001 for -500:500

% center index where t=0
[~, cIdx] = min(abs(tAxis - 0));

% base subchunk in pyr is [cIdx-chunkHalf : cIdx+chunkHalf] → 401 samples
pyrStart = cIdx - chunkHalf;
pyrEnd   = cIdx + chunkHalf;

% safety: make sure this is inside win
if pyrStart < 1 || pyrEnd > T
    error('chosen chunkHalf=%d does not fit inside the available window length=%d.', chunkHalf, T);
end

% clip max lag in bins so int shifted subchunk stays inside win for all lags
reqMaxLagBins = round(maxLagSecs / binSize);
maxLagLeft  = pyrStart - 1; % how many bins i can go - and stay in range
maxLagRight = T - pyrEnd; % how many bins i can go + and stay in range
maxLagBins  = min([reqMaxLagBins, maxLagLeft, maxLagRight]); % clip

lags = -maxLagBins:maxLagBins; % int bins

% helper: per-trial baseline subtraction on events×time (after neuron-avg)
function Eout = subtractTrialBaseline(Ein, tAxisSec, tStartSec, tEndSec)
    [~, iStart] = min(abs(tAxisSec - tStartSec));
    [~, iEnd]   = min(abs(tAxisSec - tEndSec));
    if iEnd < iStart, tmp = iStart; iStart = iEnd; iEnd = tmp; end
    baselines = mean(Ein(:, iStart:iEnd), 2, 'omitnan');  % events×1
    Eout = Ein - baselines;  % implicit expansion per event
end

% preallocate result
xc = nan(1, numel(lags));

% loop over lags
for iL = 1:numel(lags)
    L = lags(iL);  % + L means int chunk is shifted left by L bins (i.e. leads)

    % idx for int subchunk (shifted by -L)
    intStart = pyrStart - L;
    intEnd   = pyrEnd   - L;

    % sanity check
    if intStart < 1 || intEnd > T
        continue;
    end

    % holders for concat per-window subchunks
    pyrVec = [];
    intVec = [];

    % iterate channels then events, extracting subchunks and concat
    for ch = channelsToUse
        % windows: events × neurons × time
        pyrWin = S.pyrCxWinCell{ch};
        intWin = S.intCxWinCell{ch};
        if isempty(pyrWin) || isempty(intWin), continue; end

        % average across neurons -> events × time
        pyrEvt = squeeze(mean(pyrWin, 2, 'omitnan'));  % events × time
        intEvt = squeeze(mean(intWin, 2, 'omitnan'));  % events × time
        if isempty(pyrEvt) || isempty(intEvt), continue; end

        % optional per-trial baseline subtraction using -200 to -150 ms (== -0.2:-0.15 s)
        if doBaselineNorm
            pyrEvt = subtractTrialBaseline(pyrEvt, tAxis, -0.2, -0.15);
            intEvt = subtractTrialBaseline(intEvt, tAxis, -0.2, -0.15);
        end

        % number of events for this channel
        nEvt = size(pyrEvt, 1);

        % for each event, pull the 401-sample pyr subchunk and the shifted 401-sample int subchunk
        for e = 1:nEvt
            pseg = pyrEvt(e, pyrStart:pyrEnd); % 1 × (2*chunkHalf+1)
            iseg = intEvt(e, intStart:intEnd); % 1 × (2*chunkHalf+1), shifted by -L
            pyrVec = [pyrVec, pseg];
            intVec = [intVec, iseg];
        end
    end

    % remove nans, preserve alignment
    valid = ~isnan(pyrVec) & ~isnan(intVec);
    pyrVec = pyrVec(valid);
    intVec = intVec(valid);

    % compute corr if enough points
    if numel(pyrVec) > 10
        xc(iL) = corr(pyrVec', intVec');
    end
end

% find peak lag (in seconds)
[~, peakIdx] = max(xc);
peakLagSec = lags(peakIdx) * binSize;

% -------- control: no lags, use precomputed shifted windows --------
% one correlation per shift (first shift from intCxWinShiftedCell averaged over neurons,
% remaining shifts from intCxWinShiftedMeanCell which store events×time)
numStoredShifts = size(S.intCxWinShiftedMeanCell, 2); % typically 99
numShifts = 1 + numStoredShifts; % 1 (full) + 99 (means) = 100
ctrlCorrs = nan(1, numShifts);

for s = 1:numShifts
    pyrVec_ctrl = [];
    intVec_ctrl = [];

    for ch = channelsToUse
        % pyr (unshifted): events×neurons×time → avg over neurons → events×time
        pyrEvt = squeeze(mean(S.pyrCxWinCell{ch}, 2, 'omitnan'));   % events × time

        % int (already shifted for this s)
        if s == 1
            % fully saved first shift: events×neurons×time → avg over neurons → events×time
            intEvt = squeeze(mean(S.intCxWinShiftedCell{ch}, 2, 'omitnan'));
        else
            % mean-shift store: events×time (already neuron-averaged in extract step)
            intEvt = S.intCxWinShiftedMeanCell{ch, s-1};            % events × time
        end

        if isempty(pyrEvt) || isempty(intEvt), continue; end

        % apply same normalization to controls (after neuron-avg)
        if doBaselineNorm
            pyrEvt = subtractTrialBaseline(pyrEvt, tAxis, -0.2, -0.15);
            intEvt = subtractTrialBaseline(intEvt, tAxis, -0.2, -0.15);
        end

        nEvt = min(size(pyrEvt,1), size(intEvt,1));

        for e = 1:nEvt
            pseg = pyrEvt(e, pyrStart:pyrEnd);   % unshifted center window
            iseg = intEvt(e, pyrStart:pyrEnd);   % already shifted in data
            pyrVec_ctrl = [pyrVec_ctrl, pseg];
            intVec_ctrl = [intVec_ctrl, iseg];
        end
    end

    valid = ~isnan(pyrVec_ctrl) & ~isnan(intVec_ctrl);
    if nnz(valid) > 10
        ctrlCorrs(s) = corr(pyrVec_ctrl(valid)', intVec_ctrl(valid)');
    end
end

% control mean ± SEM (replaces percentiles)
ctrlMean = mean(ctrlCorrs, 'omitnan');
ctrlSEM  = std(ctrlCorrs, 'omitnan') / sqrt(sum(~isnan(ctrlCorrs)));

% -------- plot --------
figure('Name','chunked window cross-correlation (with control mean ± sem)', 'Color','w');
plot(lags * binSize, xc, 'k', 'LineWidth', 2); hold on;
if ~isnan(ctrlMean) && ~isnan(ctrlSEM)
    yline(ctrlMean - ctrlSEM, '--', 'Color', [0.5 0.5 0.5], 'LineWidth', 1.5);
    yline(ctrlMean + ctrlSEM, '--', 'Color', [0.5 0.5 0.5], 'LineWidth', 1.5);
end
xline(0, 'r--');
xline(peakLagSec, 'b--', sprintf('peak = %.3f s', peakLagSec), 'LabelVerticalAlignment','bottom');
xlabel('lag (s)'); ylabel('correlation');
title(sprintf('chunked xcorr (pyr [-%d..+%d] vs int shifted, %d chans) + control mean \\pm sem', chunkHalf, chunkHalf, numel(channelsToUse)));
legend({'xc (lags)', 'control mean \pm sem', '0 lag', 'peak'}, 'Location','best');
grid on; box off;

% save output
outFile = fullfile(animalFolder, 'concatCrossCorr_chunked_withControl.mat');
save(outFile, 'lags','binSize','xc','peakLagSec','chunkHalf','channelsToUse', 'ctrlCorrs','ctrlMean','ctrlSEM','doBaselineNorm');
fprintf('saved: %s\n', outFile);
end
