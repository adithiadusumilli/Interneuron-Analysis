function runChunkedCrossCorrelation(animalFolder, channelsToUse, chunkHalf, maxLagSecs, doBaselineNorm, nPerm)
% computes xc using per-window subchunks, then concats the subchunks
% each lag uses 401 samples per window (default = -200..+200) from pyr and int uses the same # but shifted by -lag (in bins)
% no nan padding -- nans removed synchronously after concat

% inputs:
%   animalfolder: folder w 'emg_neural_allchannels.mat'
%   channelsToUse: which emg channels to include (default is 1:4)
%   chunkhalf: half-length of subchunk (default 200 -> 400 samples)
%   maxLagsSecs: desired max lag in secs (but will be clipped to fit windows)
%   doBaselineNorm: logical, per-trial baseline subtract in [-200,-150] ms (default true)
%   nPerm: # of label-shuffle permutations (default 100)

% outputs (saved):
%   lags, binSize, xc, peakLagSec, ctrlCorrs, ctrlMean, ctrlSEM, doBaselineNorm
%   permPeakLagSecs, propLessSigned, propLessAbs, permIsSigSigned, permIsSigAbs, nPerm

if nargin < 2 || isempty(channelsToUse), channelsToUse = 1:4; end
if nargin < 3 || isempty(chunkHalf), chunkHalf = 200; end % 400 = 200*2
if nargin < 4 || isempty(maxLagSecs), maxLagSecs = 0.5; end
if nargin < 5 || isempty(doBaselineNorm), doBaselineNorm = true; end
if nargin < 6 || isempty(nPerm), nPerm = 100; end

% load emg-triggered neural activity windows
S = load(fullfile(animalFolder, 'EMG_Neural_AllChannels.mat'), 'pyrCxWinCell','intCxWinCell','intCxWinShiftedCell','intCxWinShiftedMeanCell','tAxis');

% sampling and sizes
tAxis = S.tAxis(:)';
binSize = 0.001;
T = numel(tAxis); % 1001 for -500:500

% center index where t=0
[~, cIdx] = min(abs(tAxis - 0));

% base subchunk in pyr is [cIdx-chunkHalf : cIdx+chunkHalf] → 2*chunkHalf+1 samples
pyrStart = cIdx - chunkHalf;
pyrEnd   = cIdx + chunkHalf;

% safety: make sure this is inside win
if pyrStart < 1 || pyrEnd > T
    error('chosen chunkHalf=%d does not fit inside the available window length=%d.', chunkHalf, T);
end

% clip max lag in bins so int shifted subchunk stays inside win for all lags
reqMaxLagBins = round(maxLagSecs / binSize);
maxLagLeft  = pyrStart - 1;
maxLagRight = T - pyrEnd;
maxLagBins  = min([reqMaxLagBins, maxLagLeft, maxLagRight]); % clip
lags = -maxLagBins:maxLagBins; % int bins

% helper: per-trial baseline subtraction on events×time (after neuron-avg)
function Eout = subtractTrialBaseline(Ein, tAxisSec, tStartSec, tEndSec)
    [~, iStart] = min(abs(tAxisSec - tStartSec));
    [~, iEnd]   = min(abs(tAxisSec - tEndSec));
    if iEnd < iStart, tmp = iStart; iStart = iEnd; iEnd = tmp; end
    baselines = mean(Ein(:, iStart:iEnd), 2, 'omitnan');  % events×1
    Eout = Ein - baselines;  % implicit expansion per event
end

%% ----------- UNPERMUTED: build per-channel events×time, then lag sweep -----------
% (same averaging across neurons and optional baseline subtraction as before)
pyr_byCh = cell(1, numel(channelsToUse)); % each: events×time
int_byCh = cell(1, numel(channelsToUse)); % each: events×time
for ci = 1:numel(channelsToUse)
    ch = channelsToUse(ci);
    pyrWin = S.pyrCxWinCell{ch};   % events × neurons × time
    intWin = S.intCxWinCell{ch};   % events × neurons × time
    if isempty(pyrWin) || isempty(intWin), continue; end

    % avg across neurons -> events × time
    pyrEvt = squeeze(mean(pyrWin, 2, 'omitnan'));
    intEvt = squeeze(mean(intWin, 2, 'omitnan'));
    if isempty(pyrEvt) || isempty(intEvt), continue; end

    % optional baseline subtraction using -200 to -150 ms
    if doBaselineNorm
        pyrEvt = subtractTrialBaseline(pyrEvt, tAxis, -0.2, -0.15);
        intEvt = subtractTrialBaseline(intEvt, tAxis, -0.2, -0.15);
    end

    pyr_byCh{ci} = pyrEvt;
    int_byCh{ci} = intEvt;
end

tic
[xc, peakLagSec] = lagSweepAcrossChannels(pyr_byCh, int_byCh, lags, pyrStart, pyrEnd, T, binSize);
disp(['Non-permuted, non-shifted cross-correlation analysis done, time: ' num2str(toc) ' s'])

%% ----------- CONTROL (shifted): mean ± SEM -----------
numStoredShifts = size(S.intCxWinShiftedMeanCell, 2); % typically 99
numShifts = 1 + numStoredShifts; % 1 (full) + 99 (means) = 100
ctrlCorrs = nan(1, numShifts);

for s = 1:numShifts
    pyrVec_ctrl = [];
    intVec_ctrl = [];

    tic
    for ch = channelsToUse
        % pyr (unshifted): events×neurons×time → avg over neurons → events×time
        pyrEvt = squeeze(mean(S.pyrCxWinCell{ch}, 2, 'omitnan'));

        % int (already shifted for this s)
        if s == 1
            intEvt = squeeze(mean(S.intCxWinShiftedCell{ch}, 2, 'omitnan'));
        else
            intEvt = S.intCxWinShiftedMeanCell{ch, s-1};
        end

        if isempty(pyrEvt) || isempty(intEvt), continue; end

        % optional baseline subtraction
        if doBaselineNorm
            pyrEvt = subtractTrialBaseline(pyrEvt, tAxis, -0.2, -0.15);
            intEvt = subtractTrialBaseline(intEvt, tAxis, -0.2, -0.15);
        end

        nEvt = min(size(pyrEvt,1), size(intEvt,1));
        for e = 1:nEvt
            pseg = pyrEvt(e, pyrStart:pyrEnd);   % unshifted center window
            iseg = intEvt(e, pyrStart:pyrEnd);   % already shifted in data
            pyrVec_ctrl = [pyrVec_ctrl, pseg];
            intVec_ctrl = [intVec_ctrl, iseg];
        end
    end

    valid = ~isnan(pyrVec_ctrl) & ~isnan(intVec_ctrl);
    if nnz(valid) > 10
        ctrlCorrs(s) = corr(pyrVec_ctrl(valid)', intVec_ctrl(valid)');
    end

    disp(['Cross-correlation analysis shift ' num2str(s) ' done, time: ' num2str(toc) ' s'])
end

ctrlMean = mean(ctrlCorrs, 'omitnan');
ctrlSEM  = std(ctrlCorrs, 'omitnan') / sqrt(sum(~isnan(ctrlCorrs)));

%% ----------- PERMUTATION TEST (shuff neuron labels) -----------
% per chan: pool neurons pyr+int, shuffle labels but keep original counts, then recompute full lag-swept xcorr and take peak lag
permPeakLagSecs = nan(1, nPerm);

for p = 1:nPerm
    tic
    % precompute shuffled, neuron-averaged events×time per channel
    shufPyr_byCh = cell(1, numel(channelsToUse));
    shufInt_byCh = cell(1, numel(channelsToUse));

    for ci = 1:numel(channelsToUse)
        ch = channelsToUse(ci);
        pyrWin = S.pyrCxWinCell{ch};   % events × Np × time
        intWin = S.intCxWinCell{ch};   % events × Ni × time
        if isempty(pyrWin) || isempty(intWin), continue; end

        [nEvtP, nPyr, ~] = size(pyrWin);
        [nEvtI, nInt, ~] = size(intWin);
        nEvt = min(nEvtP, nEvtI);
        if nPyr + nInt < 2 || nEvt < 1, continue; end

        % pool neurons along dim-2
        pooledWin = cat(2, pyrWin(1:nEvt,:,:), intWin(1:nEvt,:,:));  % events × (nPyr+nInt) × time
        totN = nPyr + nInt;

        % shuffle neuron indices; first nPyr assigned to "pyr", rest to "int"
        idx = randperm(totN);
        idxP = idx(1:nPyr);
        idxI = idx(nPyr+1:end);

        shufPyrEvt = squeeze(mean(pooledWin(:, idxP, :), 2, 'omitnan')); % events×time
        shufIntEvt = squeeze(mean(pooledWin(:, idxI, :), 2, 'omitnan')); % events×time

        % optional baseline subtraction
        if doBaselineNorm
            shufPyrEvt = subtractTrialBaseline(shufPyrEvt, tAxis, -0.2, -0.15);
            shufIntEvt = subtractTrialBaseline(shufIntEvt, tAxis, -0.2, -0.15);
        end

        shufPyr_byCh{ci} = shufPyrEvt;
        shufInt_byCh{ci} = shufIntEvt;
    end

    % compute lag-swept xcorr for this permutation (pool across channels & events)
    [xc_perm, pLagSec] = lagSweepAcrossChannels(shufPyr_byCh, shufInt_byCh, lags, pyrStart, pyrEnd, T, binSize); %#ok<NASGU>
    % record permuted peak lag
    permPeakLagSecs(p) = pLagSec;

    disp(['Cross-correlation analysis class permute ' num2str(p) ' done, time: ' num2str(toc) ' s'])
end

% proportion of shuffled peak lags less than the actual (signed + absolute)
propLessSigned = mean(permPeakLagSecs < peakLagSec, 'omitnan');
propLessAbs    = mean(abs(permPeakLagSecs) < abs(peakLagSec), 'omitnan');
permIsSigSigned = propLessSigned >= 0.95;
permIsSigAbs    = propLessAbs    >= 0.95;

%% ----------- Plot -----------
figure('Name','chunked window cross-correlation (with control mean ± sem + permutation test)', 'Color','w');
plot(lags * binSize, xc, 'k', 'LineWidth', 2); hold on;
if ~isnan(ctrlMean) && ~isnan(ctrlSEM)
    yline(ctrlMean - ctrlSEM, '--', 'Color', [0.5 0.5 0.5], 'LineWidth', 1.5);
    yline(ctrlMean + ctrlSEM, '--', 'Color', [0.5 0.5 0.5], 'LineWidth', 1.5);
end
xline(0, 'r--');
xline(peakLagSec, 'b--', sprintf('peak = %.3f s', peakLagSec), 'LabelVerticalAlignment','bottom');

xlabel('lag (s)'); ylabel('correlation');
ttl = sprintf(['chunked xcorr (pyr [-%d..+%d] vs int shifted, %d chans)\n' 'control mean \\pm sem; perm n=%d | frac(shuf<actual) signed=%.2f%s, abs=%.2f%s'], chunkHalf, chunkHalf, numel(channelsToUse), nPerm, propLessSigned, tern(permIsSigSigned,'*',''), propLessAbs,    tern(permIsSigAbs,'*',''));
title(ttl);
legend({'xc (lags)','control mean \pm sem','0 lag','peak'}, 'Location','best');
grid on; box off;

%% ----------- save -----------
outFile = fullfile(animalFolder, 'concatCrossCorr_chunked_withControl.mat');
save(outFile, 'lags','binSize','xc','peakLagSec','chunkHalf','channelsToUse', 'ctrlCorrs','ctrlMean','ctrlSEM','doBaselineNorm', 'permPeakLagSecs','propLessSigned','propLessAbs', 'permIsSigSigned','permIsSigAbs','nPerm');
fprintf('saved: %s\n', outFile);
end

function out = tern(cond, a, b)
    if cond, out = a; else, out = b; end
end

% ===================== helper (shared by unpermuted & permuted) =====================
function [xc, peakLagSec] = lagSweepAcrossChannels(pyr_byCh, int_byCh, lags, pyrStart, pyrEnd, T, binSize)
    xc = nan(1, numel(lags));
    for iL = 1:numel(lags)
        L = lags(iL);                  % +L means int chunk is shifted left by L bins (leads)
        intStart = pyrStart - L;
        intEnd   = pyrEnd   - L;
        if intStart < 1 || intEnd > T, continue; end

        pvec = []; ivec = [];
        for ci = 1:numel(pyr_byCh)
            pEvt = pyr_byCh{ci};
            iEvt = int_byCh{ci};
            if isempty(pEvt) || isempty(iEvt), continue; end
            nEvt = min(size(pEvt,1), size(iEvt,1));
            for e = 1:nEvt
                pseg = pEvt(e, pyrStart:pyrEnd);
                iseg = iEvt(e, intStart:intEnd);
                pvec = [pvec, pseg];
                ivec = [ivec, iseg];
            end
        end

        valid = ~isnan(pvec) & ~isnan(ivec);
        if nnz(valid) > 10
            xc(iL) = corr(pvec(valid)', ivec(valid)');
        end
    end
    [~, peakIdx] = max(xc);
    peakLagSec = lags(peakIdx) * binSize;
end
