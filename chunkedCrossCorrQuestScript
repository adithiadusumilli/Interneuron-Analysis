% chunked cross-correlation (quest script, array-aware permutation, no controls/plotting)

% base dirs for animals
baseDirs = {
    '/home/asa7288/Transfer/D026', ...
    '/home/asa7288/Transfer/D020', ...
    '/home/asa7288/Transfer/D024' ...
};

% read slurm array index and set permutation flags
jid_str = getenv('SLURM_ARRAY_TASK_ID');
if isempty(jid_str)
    jobInd = 0;
else
    jobInd = str2double(jid_str);
    if isnan(jobInd), jobInd = 0; end
end

if jobInd == 0
    isPermuted = false;
    permInd = 0;
else
    isPermuted = true;
    permInd = jobInd;
end

% pick animal folder (cycles through basedirs if array > n animals)
idxAnimal = mod(jobInd, numel(baseDirs)) + 1;
animalFolder = baseDirs{idxAnimal};

% hardcoded inputs
channelsToUse  = 1:4;
chunkHalf      = 200;
maxLagSecs     = 0.5;
doBaselineNorm = true;

% load emg-triggered neural activity windows
S = load(fullfile(animalFolder, 'EMG_Neural_AllChannels.mat'), 'pyrCxWinCell','intCxWinCell','tAxis');

% sampling and sizes
tAxis = S.tAxis(:)';
binSize = 0.001;
T = numel(tAxis); % 1001 for -500:500

% center index where t=0
[~, cIdx] = min(abs(tAxis - 0));

% base subchunk in pyr is [cIdx-chunkHalf : cIdx+chunkHalf] → 2*chunkHalf+1 samples
pyrStart = cIdx - chunkHalf;
pyrEnd   = cIdx + chunkHalf;

% clip max lag in bins so int shifted subchunk stays inside win for all lags
reqMaxLagBins = round(maxLagSecs / binSize);
maxLagLeft  = pyrStart - 1;
maxLagRight = T - pyrEnd;
maxLagBins  = min([reqMaxLagBins, maxLagLeft, maxLagRight]);
lags = -maxLagBins:maxLagBins;

% helper: per-trial baseline subtraction on events×time (after neuron-avg)
function Eout = subtractTrialBaseline(Ein, tAxisSec, tStartSec, tEndSec)
    [~, iStart] = min(abs(tAxisSec - tStartSec));
    [~, iEnd]   = min(abs(tAxisSec - tEndSec));
    if iEnd < iStart, tmp = iStart; iStart = iEnd; iEnd = tmp; end
    baselines = mean(Ein(:, iStart:iEnd), 2, 'omitnan');  % events×1
    Eout = Ein - baselines;  % implicit expansion per event
end

%% ----------- build per-channel events×time (with isPermuted check), then lag sweep -----------
pyr_byCh = cell(1, numel(channelsToUse)); % each: events×time
int_byCh = cell(1, numel(channelsToUse)); % each: events×time
for ci = 1:numel(channelsToUse)
    ch = channelsToUse(ci);
    pyrWin = S.pyrCxWinCell{ch};   % events × neurons × time
    intWin = S.intCxWinCell{ch};   % events × neurons × time
    if isempty(pyrWin) || isempty(intWin), continue; end

    % permute labels for jobs 1..100; keep original for job 0
    if isPermuted
        [nEvtP, nPyr, ~] = size(pyrWin);
        [nEvtI, nInt, ~] = size(intWin);
        nEvt = min(nEvtP, nEvtI);
        if nPyr + nInt < 2 || nEvt < 1, continue; end

        pooledWin = cat(2, pyrWin(1:nEvt,:,:), intWin(1:nEvt,:,:));  % events × (nPyr+nInt) × time
        totN = nPyr + nInt;
        idx = randperm(totN);                 % no seed set
        idxP = idx(1:nPyr);
        idxI = idx(nPyr+1:end);

        pyrEvt = squeeze(mean(pooledWin(:, idxP, :), 2, 'omitnan')); % events×time
        intEvt = squeeze(mean(pooledWin(:, idxI, :), 2, 'omitnan')); % events×time
    else
        % avg across neurons -> events × time
        pyrEvt = squeeze(mean(pyrWin, 2, 'omitnan'));
        intEvt = squeeze(mean(intWin, 2, 'omitnan'));
    end

    if doBaselineNorm
        pyrEvt = subtractTrialBaseline(pyrEvt, tAxis, -0.2, -0.15);
        intEvt = subtractTrialBaseline(intEvt, tAxis, -0.2, -0.15);
    end

    pyr_byCh{ci} = pyrEvt;
    int_byCh{ci} = intEvt;
end

tic
[xc, peakLagSec] = lagSweepAcrossChannels(pyr_byCh, int_byCh, lags, pyrStart, pyrEnd, T, binSize);
disp(['cross-correlation analysis done, time: ' num2str(toc) ' s'])

% save (no controls, no plotting)
outDir = fullfile(animalFolder, 'quest_runs');
if ~exist(outDir, 'dir'), mkdir(outDir); end

if isPermuted
    outFile = fullfile(outDir, sprintf('concatCrossCorr_chunked_perm_%03d.mat', permInd));
else
    outFile = fullfile(outDir, 'concatCrossCorr_chunked_unperm.mat');
end

save(outFile, 'lags','binSize','xc','peakLagSec','chunkHalf','channelsToUse', 'doBaselineNorm','isPermuted','jobInd','permInd','animalFolder');



% ===================== helper (same as your original) =====================
function [xc, peakLagSec] = lagSweepAcrossChannels(pyr_byCh, int_byCh, lags, pyrStart, pyrEnd, T, binSize)
    xc = nan(1, numel(lags));
    for iL = 1:numel(lags)
        L = lags(iL);                  % +L means int chunk is shifted left by L bins (leads)
        intStart = pyrStart - L;
        intEnd   = pyrEnd   - L;
        if intStart < 1 || intEnd > T, continue; end

        pvec = []; ivec = [];
        for ci = 1:numel(pyr_byCh)
            pEvt = pyr_byCh{ci};
            iEvt = int_byCh{ci};
            if isempty(pEvt) || isempty(iEvt), continue; end
            nEvt = min(size(pEvt,1), size(iEvt,1));
            for e = 1:nEvt
                pseg = pEvt(e, pyrStart:pyrEnd);
                iseg = iEvt(e, intStart:intEnd);
                pvec = [pvec, pseg];
                ivec = [ivec, iseg];
            end
        end

        valid = ~isnan(pvec) & ~isnan(ivec);
        if nnz(valid) > 10
            xc(iL) = corr(pvec(valid)', ivec(valid)');
        end
    end
    [~, peakIdx] = max(xc);
    peakLagSec = lags(peakIdx) * binSize;
end
