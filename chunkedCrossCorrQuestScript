% chunked cross-correlation (loop across animals, with permutation option, no plotting/controls)

% base dirs for animals
baseDirs = {
    '/home/asa7288/Transfer/D026', ...
    '/home/asa7288/Transfer/D020', ...
    '/home/asa7288/Transfer/D024' ...
};

% manually set jobInd before running this script
% example: jobInd = 0;  % unpermuted
%          jobInd = 1;  % first permutation, etc.

if jobInd == 0
    isPermuted = false;
    permInd = 0;
else
    isPermuted = true;
    permInd = jobInd;
end

channelsToUse  = 1:4;
chunkHalf      = 200;
maxLagSecs     = 0.5;
doBaselineNorm = true;

for iDir = 1:numel(baseDirs)
    baseDir = baseDirs{iDir};
    fprintf('\nprocessing cortex session %d: %s (job %d)\n', iDir, baseDir, jobInd);

    % load emg-triggered neural activity windows
    S = load(fullfile(baseDir, 'EMG_Neural_AllChannels.mat'), 'pyrCxWinCell','intCxWinCell','tAxis');

    % sampling and sizes
    tAxis = S.tAxis(:)';
    binSize = 0.001;
    T = numel(tAxis); % 1001 for -500:500

    % center index where t=0
    [~, cIdx] = min(abs(tAxis - 0));

    % base subchunk in pyr is [cIdx-chunkHalf : cIdx+chunkHalf]
    pyrStart = cIdx - chunkHalf;
    pyrEnd   = cIdx + chunkHalf;

    % clip max lag in bins so int shifted subchunk stays inside window
    reqMaxLagBins = round(maxLagSecs / binSize);
    maxLagLeft  = pyrStart - 1;
    maxLagRight = T - pyrEnd;
    maxLagBins  = min([reqMaxLagBins, maxLagLeft, maxLagRight]);
    lags = -maxLagBins:maxLagBins;

    % helper: per-trial baseline subtraction
    function Eout = subtractTrialBaseline(Ein, tAxisSec, tStartSec, tEndSec)
        [~, iStart] = min(abs(tAxisSec - tStartSec));
        [~, iEnd]   = min(abs(tAxisSec - tEndSec));
        if iEnd < iStart, tmp = iStart; iStart = iEnd; iEnd = tmp; end
        baselines = mean(Ein(:, iStart:iEnd), 2, 'omitnan');
        Eout = Ein - baselines;
    end

    %% ----------- build per-channel eventsÃ—time (with isPermuted check) -----------
    pyr_byCh = cell(1, numel(channelsToUse));
    int_byCh = cell(1, numel(channelsToUse));

    for ci = 1:numel(channelsToUse)
        ch = channelsToUse(ci);
        pyrWin = S.pyrCxWinCell{ch};
        intWin = S.intCxWinCell{ch};
        if isempty(pyrWin) || isempty(intWin), continue; end

        % permute labels if required
        if isPermuted
            [nEvtP, nPyr, ~] = size(pyrWin);
            [nEvtI, nInt, ~] = size(intWin);
            nEvt = min(nEvtP, nEvtI);
            if nPyr + nInt < 2 || nEvt < 1, continue; end

            pooledWin = cat(2, pyrWin(1:nEvt,:,:), intWin(1:nEvt,:,:));
            totN = nPyr + nInt;
            idx = randperm(totN);
            idxP = idx(1:nPyr);
            idxI = idx(nPyr+1:end);

            pyrEvt = squeeze(mean(pooledWin(:, idxP, :), 2, 'omitnan'));
            intEvt = squeeze(mean(pooledWin(:, idxI, :), 2, 'omitnan'));
        else
            pyrEvt = squeeze(mean(pyrWin, 2, 'omitnan'));
            intEvt = squeeze(mean(intWin, 2, 'omitnan'));
        end

        if doBaselineNorm
            pyrEvt = subtractTrialBaseline(pyrEvt, tAxis, -0.2, -0.15);
            intEvt = subtractTrialBaseline(intEvt, tAxis, -0.2, -0.15);
        end

        pyr_byCh{ci} = pyrEvt;
        int_byCh{ci} = intEvt;
    end

    %% ----------- compute lag-swept correlation -----------
    tic
    [xc, peakLagSec] = lagSweepAcrossChannels(pyr_byCh, int_byCh, lags, pyrStart, pyrEnd, T, binSize);
    disp(['cross-correlation analysis done, time: ' num2str(toc) ' s'])

    %% ----------- save results -----------
    outDir = fullfile(baseDir, 'quest_runs');
    if ~exist(outDir, 'dir'), mkdir(outDir); end

    if isPermuted
        outFile = fullfile(outDir, sprintf('concatCrossCorr_chunked_perm_%03d.mat', permInd));
    else
        outFile = fullfile(outDir, 'concatCrossCorr_chunked_unperm.mat');
    end

    save(outFile, 'lags','binSize','xc','peakLagSec','chunkHalf','channelsToUse', ...
        'doBaselineNorm','isPermuted','jobInd','permInd','baseDir');
end



% ===================== helper =====================
function [xc, peakLagSec] = lagSweepAcrossChannels(pyr_byCh, int_byCh, lags, pyrStart, pyrEnd, T, binSize)
    xc = nan(1, numel(lags));
    for iL = 1:numel(lags)
        L = lags(iL);
        intStart = pyrStart - L;
        intEnd   = pyrEnd   - L;
        if intStart < 1 || intEnd > T, continue; end

        pvec = []; ivec = [];
        for ci = 1:numel(pyr_byCh)
            pEvt = pyr_byCh{ci};
            iEvt = int_byCh{ci};
            if isempty(pEvt) || isempty(iEvt), continue; end
            nEvt = min(size(pEvt,1), size(iEvt,1));
            for e = 1:nEvt
                pseg = pEvt(e, pyrStart:pyrEnd);
                iseg = iEvt(e, intStart:intEnd);
                pvec = [pvec, pseg];
                ivec = [ivec, iseg];
            end
        end

        valid = ~isnan(pvec) & ~isnan(ivec);
        if nnz(valid) > 10
            xc(iL) = corr(pvec(valid)', ivec(valid)');
        end
    end
    [~, peakIdx] = max(xc);
    peakLagSec = lags(peakIdx) * binSize;
end
