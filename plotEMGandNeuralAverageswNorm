function plotEMGandNeuralAverageswNorm(dataFile, channelsToUse, doBaselineNorm)
% plots mean ± sem traces for emg, cortex-pyr, cortex-int, striatum-pyr, and striatum-int
% data comes from output of extractEMGandNeuralWindows func
% only events originating from the specified emg channels are pooled

% inputs:
%   datafile: full path to 'emg_neural_allchannels.mat' or equiv based on timeframe im extracting
%   channelstouse: vector with channel inds to pool (default = 1:4)
%   doBaselineNorm: logical, per-trial baseline subtract (-200 to -150 ms) after avg across neurons but before avg across trials (default = true)

    if nargin < 2 || isempty(channelsToUse), channelsToUse = 1:4; end
    if nargin < 3 || isempty(doBaselineNorm), doBaselineNorm = true; end

    % add shadederrorbar (edit path if moved)
    sep = 'c:\github\interneuron-analysis';
    fcn = fullfile(sep,'shadedErrorBar.m');
    if exist(fcn,'file'), addpath(genpath(sep)); end

    % load variables saved by extractEMGandNeuralWindows
    S = load(dataFile, 'emgWindowsCell','pyrCxWinCell','intCxWinCell','pyrStrWinCell','intStrWinCell','tAxis', 'pyrCxWinShiftedCell','intCxWinShiftedCell','pyrStrWinShiftedCell','intStrWinShiftedCell', 'pyrCxWinShiftedMeanCell','intCxWinShiftedMeanCell','pyrStrWinShiftedMeanCell','intStrWinShiftedMeanCell');

    % -------- helper funcs --------
    % avg across neurons -> (events x time)
    meanEvt = @(M) squeeze(mean(M, 2, 'omitnan'));

    % grand mean and sem across events
    grandMS = @(E) deal(mean(E,1,'omitnan'), std(E,0,1,'omitnan')./sqrt(size(E,1)));

    % per-trial baseline subtraction using -200 to -150 ms window
    function Eout = subtractTrialBaseline(Ein, tAxis, tStart, tEnd) % events out = output matrix after baseline subtraction
        % ein: events x time (input matrix that needs to be normalized)
        [~, iStart] = min(abs(tAxis - tStart));
        [~, iEnd]   = min(abs(tAxis - tEnd));
        if iEnd < iStart, tmp=iStart; iStart=iEnd; iEnd=tmp; end
        baselines = mean(Ein(:, iStart:iEnd), 2, 'omitnan'); % events x 1
        Eout = Ein - baselines; % implicit expansion per event
    end

    % -------- 1) pool events from requested emg channels --------
    emgPool   = []; % events x time
    pyrCxPool = []; % events x neurons x time
    intCxPool = [];
    pyrStrPool= [];
    intStrPool= [];

    for ch = channelsToUse
        % emg windows for the triggering muscle (dim-2 = ch)
        emgChunk = squeeze(S.emgWindowsCell{ch}(:, ch, :)); % events x time
        emgPool  = cat(1, emgPool, emgChunk);

        % neural windows
        pyrCxPool  = cat(1, pyrCxPool , S.pyrCxWinCell{ch});  % events x neurons x time
        intCxPool  = cat(1, intCxPool , S.intCxWinCell{ch});
        pyrStrPool = cat(1, pyrStrPool, S.pyrStrWinCell{ch});
        intStrPool = cat(1, intStrPool, S.intStrWinCell{ch});
    end

    % -------- 2) unshifted neural: avg across neurons -> per-trial baseline -> mean/sem --------
    % average across neurons -> events x time
    pyrCx_evt  = meanEvt(pyrCxPool);
    intCx_evt  = meanEvt(intCxPool);
    pyrStr_evt = meanEvt(pyrStrPool);
    intStr_evt = meanEvt(intStrPool);

    % per-trial baseline subtraction before averaging across trials
    if doBaselineNorm
        pyrCx_evt  = subtractTrialBaseline(pyrCx_evt , S.tAxis, -200, -150);
        intCx_evt  = subtractTrialBaseline(intCx_evt , S.tAxis, -200, -150);
        pyrStr_evt = subtractTrialBaseline(pyrStr_evt, S.tAxis, -200, -150);
        intStr_evt = subtractTrialBaseline(intStr_evt, S.tAxis, -200, -150);
    end

    % compute mean ± sem across events
    [mPyrCx , sePyrCx ] = grandMS(pyrCx_evt);
    [mIntCx , seIntCx ] = grandMS(intCx_evt);
    [mPyrStr, sePyrStr] = grandMS(pyrStr_evt);
    [mIntStr, seIntStr] = grandMS(intStr_evt);

    % -------- 3) shifted controls: per-trial baseline first, then average to 1xtime per shift --------
    % build matrix where each row is one shift's 1 x time mean (after per-trial baseline subtraction)
    function allShiftsMat = buildShiftMat(firstShiftCell, meanShiftCell, tAxis)
        % output: (#channels*100) x time (100 shifts per channel)
        allShiftsMat = [];
        for ch = channelsToUse
            % first shift (fully saved): events x neurons x time -> events x time
            E_first = meanEvt(firstShiftCell{ch});     % events x time
            if doBaselineNorm
                E_first = subtractTrialBaseline(E_first, tAxis, -200, -150);
            end
            row_first = mean(E_first, 1, 'omitnan');   % 1 x time

            % remaining 99 shifts: each is events x time (already neuron-averaged when saved)
            numStored = numel(meanShiftCell(ch, :));   % expected 99
            rowList = zeros(numStored, numel(tAxis));
            for k = 1:numStored
                E = meanShiftCell{ch, k};              % events x time
                if doBaselineNorm
                    E = subtractTrialBaseline(E, tAxis, -200, -150);
                end
                rowList(k, :) = mean(E, 1, 'omitnan'); % 1 x time
            end

            % stack 100 x time for this channel then accumulate
            chanMat = [row_first; rowList];            % 100 x time
            allShiftsMat = cat(1, allShiftsMat, chanMat);
        end
    end

    pyrCx_shiftMat  = buildShiftMat(S.pyrCxWinShiftedCell , S.pyrCxWinShiftedMeanCell , S.tAxis);
    intCx_shiftMat  = buildShiftMat(S.intCxWinShiftedCell , S.intCxWinShiftedMeanCell , S.tAxis);
    pyrStr_shiftMat = buildShiftMat(S.pyrStrWinShiftedCell, S.pyrStrWinShiftedMeanCell, S.tAxis);
    intStr_shiftMat = buildShiftMat(S.intStrWinShiftedCell, S.intStrWinShiftedMeanCell, S.tAxis);

  % compute shifted-control mean ± SEM across shifts (rows)
    [pyrCx_shiftMean , pyrCx_shiftSEM ] = grandMS(pyrCx_shiftMat);
    [intCx_shiftMean , intCx_shiftSEM ] = grandMS(intCx_shiftMat);
    [pyrStr_shiftMean, pyrStr_shiftSEM] = grandMS(pyrStr_shiftMat);
    [intStr_shiftMean, intStr_shiftSEM] = grandMS(intStr_shiftMat);

    % precompute lower/upper bounds for plotting
    pyrCx_sem = [pyrCx_shiftMean - pyrCx_shiftSEM; pyrCx_shiftMean + pyrCx_shiftSEM];
    intCx_sem = [intCx_shiftMean - intCx_shiftSEM; intCx_shiftMean + intCx_shiftSEM];
    pyrStr_sem = [pyrStr_shiftMean - pyrStr_shiftSEM; pyrStr_shiftMean + pyrStr_shiftSEM];
    intStr_sem = [intStr_shiftMean - intStr_shiftSEM; intStr_shiftMean + intStr_shiftSEM];

    % -------- 4) emg mean & sem (unchanged) --------
    mEMG = mean(emgPool , 1 , 'omitnan'); 
    seEMG = std (emgPool , 0 , 1 , 'omitnan') ./ sqrt(size(emgPool,1)); 

    % -------- 5) plot (2 x 2) with yyaxis and shifted percentile bounds --------
    figure('Name','unshifted neural (baseline-subtracted) + 95% shifted percentile bounds','Color','w');
    tiledlayout(2, 2, 'TileSpacing', 'tight', 'Padding', 'compact');

    % cortex neural
    nexttile(1); hold on;
    yyaxis left
    shadedErrorBar(S.tAxis, mPyrCx, sePyrCx, 'lineProps', {'b', 'LineWidth', 1.5});
    plot(S.tAxis, pyrCx_sem(1,:), 'b--');   % mean - sem
    plot(S.tAxis, pyrCx_sem(2,:), 'b--');   % mean + sem
    ylabel('pyramidal');

    yyaxis right
    shadedErrorBar(S.tAxis, mIntCx, seIntCx, 'lineProps', {'r', 'LineWidth', 1.5});
    plot(S.tAxis, intCx_sem(1,:), 'r--');   % mean - sem
    plot(S.tAxis, intCx_sem(2,:), 'r--');   % mean + sem
    ylabel('interneuron');
    title('cortex neural');
    xlabel('time (ms)');

    % striatum neural
    nexttile(2); hold on;
    yyaxis left
    shadedErrorBar(S.tAxis, mPyrStr, sePyrStr, 'lineProps', {'b', 'LineWidth', 1.5});
    plot(S.tAxis, pyrStr_sem(1,:), 'b--');  % mean - sem
    plot(S.tAxis, pyrStr_sem(2,:), 'b--');  % mean + sem
    ylabel('pyramidal');
    
    yyaxis right
    shadedErrorBar(S.tAxis, mIntStr, seIntStr, 'lineProps', {'r', 'LineWidth', 1.5});
    plot(S.tAxis, intStr_sem(1,:), 'r--');  % mean - sem
    plot(S.tAxis, intStr_sem(2,:), 'r--');  % mean + sem
    ylabel('interneuron');
    title('striatum neural');
    xlabel('time (ms)');


    sgtitle(sprintf('unshifted neural%s + 95%% shifted percentile bounds', tern(doBaselineNorm,' (baseline-subtracted)','')));

end

% helper for title string lol
function out = tern(cond, a, b)
    if cond, out = a; else, out = b; end
end
